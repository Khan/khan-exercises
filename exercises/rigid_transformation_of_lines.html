<!DOCTYPE html>
<html data-require="math graphie interactive">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Rigid transformation of a line</title>
    <script src="../khan-exercise.js"></script>
</head>
<body>
<div class="exercise">
    <div class="vars">
        <var id="RADIUS">randRange(2, 8) / 2</var>
        <var id="ANGLE">randRange(1, 12) * PI / 12</var>
        <var id="MIDX">randRange(RADIUS - 10, 10 - RADIUS)</var>
        <var id="MIDY">randRange(RADIUS - 10, 10 - RADIUS)</var>
        <var id="START_LINE">[
            [MIDX + RADIUS * cos(ANGLE), MIDY + RADIUS * sin(ANGLE)],
            [MIDX - RADIUS * cos(ANGLE), MIDY - RADIUS * sin(ANGLE)]
        ]</var>

        <var id="RADIUS2" data-ensure="abs(RADIUS - RADIUS2) !== 0.5">random() &lt; 0.7 ? RADIUS : randRange(2, 8) / 2</var>
        <div data-ensure="abs(MIDX2 - MIDX) + abs(MIDY2 - MIDY) &gt; 3">
            <var id="ANGLE2">randRange(1, 12) * PI / 12</var>
            <var id="MIDX2">randRange(RADIUS2 - 10, 10 - RADIUS2)</var>
            <var id="MIDY2">randRange(RADIUS2 - 10, 10 - RADIUS2)</var>
            <var id="TARGET">[
                [MIDX2 + RADIUS2 * cos(ANGLE2), MIDY2 + RADIUS2 * sin(ANGLE2)],
                [MIDX2 - RADIUS2 * cos(ANGLE2), MIDY2 - RADIUS2 * sin(ANGLE2)]
            ]</var>
        </div>
        <var id="GRAPH">{}</var>
    </div>

    <div class="problems">
        <div id="line-segment">
            <p class="question">
                Can transform the blue line segment into the green line using translations and rotations?
            </p>

            <div class="problem">
                <div class="graphie" id="grid">
                    graphInit({
                        range: 11,
                        scale: 20,
                        axisArrows: "&lt;-&gt;",
                        tickStep: 1,
                        labelStep: 1,
                        gridOpacity: 0.05,
                        axisOpacity: 0.2,
                        tickOpacity: 0.4,
                        labelOpacity: 0.5
                    });
                    addMouseLayer();

                    path(START_LINE, { stroke: GRAY, strokeDasharray: "- " });
                    path(TARGET, { stroke: GREEN, "stroke-width": 3 });
                    GRAPH = graph;

                    graph.points = [
                        addMovablePoint({ coord: START_LINE[0] }),
                        addMovablePoint({ coord: START_LINE[1] })
                    ];

                    graph.lines = [];
                    graph.lines.push(addMovableLineSegment({
                        pointA: graph.points[0],
                        pointZ: graph.points[1],
                        onMove: function(dX, dY) {
                            graph.updatePolygon(dX, dY);
                        }
                    }));

                    graph.showLine = function() {
                        graph.points[0].visibleShape.show();
                        graph.points[0].mouseTarget.show();
                        graph.points[1].visibleShape.show();
                        graph.points[1].mouseTarget.show();
                        graph.lines[0].visibleLine.show();
                    };

                    graph.hideLine = function() {
                        graph.points[0].visibleShape.hide();
                        graph.points[0].mouseTarget.hide();
                        graph.points[1].visibleShape.hide();
                        graph.points[1].mouseTarget.hide();
                        graph.lines[0].visibleLine.hide();
                    };

                    graph.origOffsets = _.map(graph.points, function(point) {
                        var angle = atan2(point.coord[1], point.coord[0]);
                        return angle - roundToNearest(PI / 6, angle);
                    });

                    graph.findMidPoint = function() {
                        var midX = _.reduce(graph.points, function(sum, point) {
                            return sum + point.coord[0];
                        }, 0) / graph.points.length;
                        var midY = _.reduce(graph.points, function(sum, point) {
                            return sum + point.coord[1];
                        }, 0) / graph.points.length;

                        graph.midPoint = [midX, midY];
                    };
                    graph.findMidPoint();

                    graph.matchMidPoint = function() {
                        var dX = MIDX2 - graph.midPoint[0];
                        var dY = MIDY2 - graph.midPoint[1];
                        graph.updatePolygon(dX, dY);
                    }

                    graph.matchRotation = function() {
                        var currentAngle = atan2(graph.points[0].coord[1] - graph.midPoint[1], graph.points[0].coord[0] - graph.midPoint[0]);
                        graph.rotatePolygon(ANGLE2 - currentAngle);
                    }

                    _.each(graph.points, function(point) {
                        point.onMove = function(x, y) {
                            var oldAngle = atan2(this.coord[1] - graph.midPoint[1], this.coord[0] - graph.midPoint[0]);
                            var newAngle = atan2(y - graph.midPoint[1], x - graph.midPoint[0]);
                            graph.rotatePolygon(newAngle - oldAngle);
                            return false;
                        }
                    });

                    graph.rotatePolygon = function(rad) {
                        var degrees = roundToNearest(15, rad * 180 / PI);
                        rad = degrees * PI / 180;
                        var c = cos(rad);
                        var s = sin(rad);

                        _.each(graph.points, function(point) {
                            point.setCoord([
                                graph.midPoint[0] + (point.coord[0] - graph.midPoint[0]) * c + (graph.midPoint[1] - point.coord[1]) * s,
                                graph.midPoint[1] + (point.coord[0] - graph.midPoint[0]) * s + (point.coord[1] - graph.midPoint[1]) * c
                            ]);
                            point.updateLineEnds();
                        });
                    };

                    graph.updatePolygon = function(dX, dY) {
                        graph.findMidPoint();
                        dX = round(dX);
                        dY = round(dY);

                        _.each(graph.points, function(point) {
                            point.setCoord([
                                point.coord[0] += dX,
                                point.coord[1] += dY
                            ]);
                            point.updateLineEnds();
                        });
                        graph.findMidPoint();
                    };
                </div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">
                    Can you drag and rotate the blue line segment onto the green line?<br>
                    <ul>
                        <li>
                            <label>
                                <input id="exists" checked name="transform" onclick="KhanUtil.tmpl.getVAR('GRAPH').showLine()" type="radio">
                                <span>Yes, the blue line segment can be transformed into the green line</span>
                            </label>
                        </li>
                        <li>
                            <label>
                                <input id="notexists" name="transform" onclick="KhanUtil.tmpl.getVAR('GRAPH').hideLine()" type="radio">
                                <span>No, the blue line segment cannot be transformed into the green line</span>
                            </label>
                        </li>
                    </ul>
                </div>
                <div class="guess">[_.map(graph.points, function(point) {
                        return point.coord;
                    }), $("input[name='transform']:checked").attr("id")]
                </div>
                <div class="validator-function">
                    if (guess[1] === "notexists") {
                        return RADIUS !== RADIUS2;
                    } else {

                        var match = _.all(guess[0], function(point, i) {
                            var d = abs(point[0] - TARGET[i][0]) +  abs(point[1] - TARGET[i][1]);
                            return abs(point[0] - TARGET[i][0]) &lt; 0.4 &amp;&amp; abs(point[1] - TARGET[i][1]) &lt; 0.4;
                        });

                        if (match) {
                            return true;
                        } else {
                            // Check opposite order
                            var n = guess.length - 1;
                            return _.all(guess[0], function(point, i) {
                                return abs(point[0] - TARGET[n - i][0]) &lt; 0.4 &amp;&amp; abs(point[1] - TARGET[n - i][1]) &lt; 0.4;
                            });
                        }
                    }
                </div>
                <div class="show-guess">
                    _.each(graph.points, function(point, n) {
                        point.setCoord(guess[n]);
                        point.updateLineEnds();
                    });
                </div>
            </div>

            <div class="hints">
                <div>
                    <p>First try translating the blue line segment so its middle is in the same place as the middle of the green line segement.</p>
                    <div>
                        <button onclick="javascript: KhanUtil.currentGraph.graph.matchMidPoint(); ">Show me</button>
                    </div>
                </div>
                <div>
                    <p>Now try rotating the blue line segment so has the same orientation as the green line segement.</p>
                    <div>
                        <button onclick="javascript: KhanUtil.currentGraph.graph.matchRotation(); ">Show me</button>
                    </div>
                </div>
                <p data-if="RADIUS === RADIUS2">
                    The blue line segment completely overlaps the green line segement, so it can be transformed into it.
                </p>
                <p data-else="">
                    The two line segements have different lengths so you cannot transform one into the other using just translation and rotation transformations.
                </p>
            </div>
        </div>
    </div>
</div>
</body>
</html>
