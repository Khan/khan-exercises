<!DOCTYPE html>
<html data-require="math graphie interactive">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Rigid transformation of a line</title>
    <script src="../khan-exercise.js"></script>
</head>
<body>
<div class="exercise">
    <div class="vars">
        <var id="RADIUS">randRange(5, 16) / 4</var>
        <var id="ANGLE">randRange(1, 12) * PI / 12</var>
        <var id="MIDX">randRange(RADIUS - 10, 10 - RADIUS)</var>
        <var id="MIDY">randRange(RADIUS - 10, 10 - RADIUS)</var>
        <var id="START_LINE">[
            [MIDX + RADIUS * cos(ANGLE), MIDY + RADIUS * sin(ANGLE)],
            [MIDX - RADIUS * cos(ANGLE), MIDY - RADIUS * sin(ANGLE)]
        ]</var>
        <div data-ensure="abs(MIDX2 - MIDX) + abs(MIDY2 - MIDY) &gt; 3">
            <var id="ANGLE2">randRange(1, 12) * PI / 12</var>
            <var id="MIDX2">randRange(RADIUS - 10, 10 - RADIUS)</var>
            <var id="MIDY2">randRange(RADIUS - 10, 10 - RADIUS)</var>
            <var id="TARGET">[
                [MIDX2 + RADIUS * cos(ANGLE2), MIDY2 + RADIUS * sin(ANGLE2)],
                [MIDX2 - RADIUS * cos(ANGLE2), MIDY2 - RADIUS * sin(ANGLE2)]
            ]</var>
        </div>
        <var id="GRAPH">{}</var>
    </div>

    <div class="problems">
        <div id="drag">
            <p class="question">
                Can transform the blue line into the green line using translations and rotations?
            </p>

            <div class="problem">
                <div class="graphie" id="grid">
                    graphInit({
                        range: 11,
                        scale: 20,
                        axisArrows: "&lt;-&gt;",
                        tickStep: 1,
                        labelStep: 1,
                        gridOpacity: 0.05,
                        axisOpacity: 0.2,
                        tickOpacity: 0.4,
                        labelOpacity: 0.5
                    });
                    addMouseLayer();

                    path(START_LINE, { stroke: GRAY, strokeDasharray: "- " });
                    path(TARGET, { stroke: GREEN, "stroke-width": 3 });
                    GRAPH = graph;

                    graph.points = [
                        addMovablePoint({ coord: START_LINE[0] }),
                        addMovablePoint({ coord: START_LINE[1] })
                    ];

                    graph.lines = [];
                    graph.lines.push(addMovableLineSegment({
                        pointA: graph.points[0],
                        pointZ: graph.points[1],
                        onMove: function(dX, dY) {
                            graph.updatePolygon(dX, dY);
                        }
                    }));

                    graph.showLine = function() {
                        graph.points[0].visibleShape.show();
                        graph.points[0].mouseTarget.show();
                        graph.points[1].visibleShape.show();
                        graph.points[1].mouseTarget.show();
                        graph.lines[0].visibleLine.show();
                    };

                    graph.hideLine = function() {
                        graph.points[0].visibleShape.hide();
                        graph.points[0].mouseTarget.hide();
                        graph.points[1].visibleShape.hide();
                        graph.points[1].mouseTarget.hide();
                        graph.lines[0].visibleLine.hide();
                    };

                    graph.origOffsets = _.map(graph.points, function(point) {
                        var angle = atan2(point.coord[1], point.coord[0]);
                        return angle - roundToNearest(PI / 6, angle);
                    });

                    graph.findMidPoint = function() {
                        var midX = _.reduce(graph.points, function(sum, point) {
                            return sum + point.coord[0];
                        }, 0) / graph.points.length;
                        var midY = _.reduce(graph.points, function(sum, point) {
                            return sum + point.coord[1];
                        }, 0) / graph.points.length;

                        graph.midPoint = [midX, midY];
                    };
                    graph.findMidPoint();

                    _.each(graph.points, function(point) {
                        point.onMove = function(x, y) {
                            var oldAngle = atan2(this.coord[1] - graph.midPoint[1], this.coord[0] - graph.midPoint[0]);
                            var newAngle = atan2(y - graph.midPoint[1], x - graph.midPoint[0]);

                            var changeDegrees = (newAngle - oldAngle) * 180 / PI;
                            changeDegrees = floor(changeDegrees / 15) * 15;
                            graph.rotatePolygon(changeDegrees * PI / 180);

                            return false;
                        }

                        point.onMoveEnd = function(x, y) {
                            var oldAngle = atan2(this.coord[1], this.coord[0]);
                            var newAngle = roundToNearest(PI/6, atan2(y, x));
                            var possibleSnaps = [
                                graph.origOffsets[_.indexOf(graph.points, this)] + newAngle - oldAngle,
                                graph.origOffsets[_.indexOf(graph.points, this)] + newAngle - oldAngle + PI / 6,
                                graph.origOffsets[_.indexOf(graph.points, this)] + newAngle - oldAngle - PI / 6
                            ];

                            var absSnaps = _.map(possibleSnaps, function(rad) { return abs(rad); });
                            var absMoveTo = min(absSnaps[0], absSnaps[1], absSnaps[2]);
                            var moveTo = _.find(possibleSnaps, function(rad) { return abs(rad) === absMoveTo; });

                            //graph.rotatePolygon(moveTo);
                        }
                    });

                    graph.rotatePolygon = function(rad) {
                        var c = cos(rad);
                        var s = sin(rad);

                        _.each(graph.points, function(point) {
                            point.setCoord([
                                graph.midPoint[0] + (point.coord[0] - graph.midPoint[0]) * c + (graph.midPoint[1] - point.coord[1]) * s,
                                graph.midPoint[1] + (point.coord[0] - graph.midPoint[0]) * s + (point.coord[1] - graph.midPoint[1]) * c
                            ]);
                            point.updateLineEnds();
                        });
                    };

                    graph.snapToHalf = function(x) {
                        var d = x - floor(x);
                        if (d &lt; 0.25) {
                            return -d;
                        } else if (d &lt; 0.75) {
                            return 0.5 - d;
                        } else {
                            return 1 - d;
                        }
                    };

                    graph.updatePolygon = function(dX, dY) {
                        graph.findMidPoint();
                        dX += graph.snapToHalf(graph.midPoint[0]);
                        dY += graph.snapToHalf(graph.midPoint[1]);

                        _.each(graph.points, function(point) {
                            point.setCoord([
                                point.coord[0] += dX,
                                point.coord[1] += dY
                            ]);
                            point.updateLineEnds();
                        });
                        graph.findMidPoint();
                    };
                </div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">
                    Can you drag and rotate the blue line onto the green line?<br>
                    <ul>
                        <li>
                            <label>
                                <input id="exists" checked name="transform" onclick="KhanUtil.tmpl.getVAR('GRAPH').showLine()" type="radio">
                                <span>Yes, the blue line can be transformed into the green line</span>
                            </label>
                        </li>
                        <li>
                            <label>
                                <input id="notexists" name="transform" onclick="KhanUtil.tmpl.getVAR('GRAPH').hideLine()" type="radio">
                                <span>No, the blue line can be transformed into the green line</span>
                            </label>
                        </li>
                    </ul>
                </div>
                <div class="guess">[_.map(graph.points, function(point) {
                        return point.coord;
                    }), $("input[name='transform']:checked").attr("id")]
                </div>
                <div class="validator-function">
                    if (guess[1] !== "exists") {
                        return false;
                    } else {

                        var match = _.all(guess[0], function(point, i) {
                            var d = abs(point[0] - TARGET[i][0]) +  abs(point[1] - TARGET[i][1]);
                            return abs(point[0] - TARGET[i][0]) &lt; 0.4 &amp;&amp; abs(point[1] - TARGET[i][1]) &lt; 0.4;
                        });

                        if (match) {
                            return true;
                        } else {
                            // Check opposite order
                            var n = guess.length - 1;
                            return _.all(guess[0], function(point, i) {
                                return abs(point[0] - TARGET[n - i][0]) &lt; 0.4 &amp;&amp; abs(point[1] - TARGET[n - i][1]) &lt; 0.4;
                            });
                        }
                    }
                </div>
                <div class="show-guess">
                    _.each(graph.points, function(point, n) {
                        point.setCoord(guess[n]);
                        point.updateLineEnds();
                    });
                </div>
            </div>

            <div class="hints">
                <div>
                    <p>
                        To see where a rotation moved this polygon, pick one
                        point and rotate it. For example, what happens to
                        <code>(<var> START_LINE[0].x </var>,<var> START_LINE[0].y </var>)</code>
                        under this rotation?
                    </p>
                    <div class="graphie" data-update="grid">
                        circle([START_LINE[0].x, START_LINE[0].y], { r: 0.2, fill: "black", stroke: "none" });
                    </div>
                </div>
                <div>
                    <p>
                        The orange outline shows where the polygon ends up after
                        the translation.
                    </p>
                    <div class="graphie" data-update="grid">
                        for (var i=0; i &lt; TARGET.length; i++) {
                            line(TARGET[i], TARGET[(i+1) % TARGET.length], { stroke: ORANGE });
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
