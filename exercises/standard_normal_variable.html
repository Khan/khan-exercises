<!DOCTYPE html>
<html data-require="math graphie stat interactive">
<head>
	<meta charset="UTF-8" />
	<title>The standard normal variable</title>
	<script src="../khan-exercise.js"></script>
	<script type="text/javascript">
	function updateArrow(x, y, z, mean, stddev) {
		var graph = KhanUtil.currentGraph;

		graph.graph.leftArrow.remove();
		graph.graph.rightArrow.remove();
		graph.graph.meanLabel.remove();

		graph.style({ arrows: "-&gt;", stroke: KhanUtil.GREEN }, function() {
			graph.graph.leftArrow = graph.path([
				[ mean + stddev * ( x + y ) / 2, -1.2 ],
				[ mean + stddev * x, -1.2 ]
			]);
			graph.graph.rightArrow = graph.path([
				[ mean + stddev * ( x + y ) / 2, -1.2 ],
				[ mean + stddev * y, -1.2 ]
			]);
		});

		graph.graph.meanLabel = graph.label( [ mean + stddev * ( x + y ) / 2, -1.4 ],
		KhanUtil.roundTo( 2, z ) + "\\%", "above", { color: KhanUtil.GREEN } );

	}
	</script>
	<script type="text/javascript">
	function updateLine(x, y) {
		var graph = KhanUtil.currentGraph;

		graph.graph.zLine[ x ].attr({ stroke: "#bbb" });
		graph.graph.zLabel[ x ].css({ color: "#bbb" });

		graph.graph.zLine[ y ].attr({ stroke: KhanUtil.PINK });
		graph.graph.zLabel[ y ].css({ color: KhanUtil.PINK });
	}
	</script>
	<script type="text/javascript">
	function updateShape(x, y, mean, stddev) {
		var graph = KhanUtil.currentGraph;
		var step = stddev / 50;
		blueShape = [];
		graph.graph.blueShape.remove();

		blueShape.push([ mean + stddev * x, 0 ]);

		for ( var i = mean + stddev * x; i <= mean + stddev * y; i += step ) {
			blueShape.push([ i, graph.graph.pdf( i ) ]);
		}

		blueShape.push([ mean + stddev * y, graph.graph.pdf( mean + stddev * y ) ]);
		blueShape.push([ mean + stddev * y, 0 ]);
		blueShape.push([ mean + stddev * x, 0 ]);

		graph.style({ stroke: null, fill: KhanUtil.BLUE, opacity: 0.3 }, function() {
			graph.graph.blueShape = graph.path( blueShape );
		});
	}
	</script>
</head>
<body>
	<div class="exercise">
		<div class="problems">
			<div id="original">
				<div class="vars">
					<var id="MEAN">0</var>
					<var id="STDDEV">1</var>
					<var id="Z1">randRange( -3, 2 )</var>
					<var id="Z2">randRange( Z1 + 1, 3 )</var>
					<var id="EMPIRICAL">
						{
							"3": 99.85,
							"2": 97.5,
							"1": 84,
							"0": 50,
							"-1": 16,
							"-2": 2.5,
							"-3": 0.15
						}
					</var>
				</div>

				<div class="problem">
					A random variable <code>x</code> is normally distributed with a mean of <code><var>MEAN</var></code> and a standard deviation 
					of <code><var>STDDEV</var></code>. This is known as the standard normal variable and its probability distribution is shown below. 
					The labeled percentage is derived using the empirical rule.
				</div>

				<div class="question">
					<p><b>Move the points to estimate the probability that <code>x</code> is between <code><var>MEAN + Z1 * STDDEV</var></code> 
					and <code><var>MEAN + Z2 * STDDEV</var></code>.</b></p>

					<div class="graphie" id="normaldist">
							init({
								range: [ [ MEAN - STDDEV * 3.5, MEAN + STDDEV * 3.5 ], [ -1.5, 4.7 ] ],
								scale: [ 600 / ( STDDEV * 7 ), 40 ]
							});

							style({ stroke: "#bbb" }, function() {
								line( [ MEAN - STDDEV * 4, 0 ], [ MEAN + STDDEV * 4, 0 ] );
							});

							graph.pdf = function( x ) {
								return gaussianPDF( MEAN, STDDEV, x ) * 4 / gaussianPDF( MEAN, STDDEV, MEAN ) + 0.2;
							};

							style({ stroke: BLUE }, function() {
								plot( graph.pdf, [ MEAN - STDDEV * 3.5, MEAN + STDDEV * 3.5 ]);
							});

							graph.zLine = [];
							graph.zLabel = [];

							style({ stroke: "#bbb" }, function() {
								var i = 1;
								graph.zLine[ 0 ] = line( [ MEAN, 0 ], [ MEAN, graph.pdf( MEAN ) ] ).toBack();
								graph.zLabel[ 0 ] = label( [ MEAN, 0 ], roundTo( 1, MEAN ), "below", { color: "#bbb" } );
								while ( i &lt; 4 ) {
									graph.zLine[ -i ] = line( [ MEAN - STDDEV * i, 0 ], [ MEAN - STDDEV * i, graph.pdf( MEAN - STDDEV * i ) ] ).toBack();
									graph.zLine[ i ] = line( [ MEAN + STDDEV * i, 0 ], [ MEAN + STDDEV * i, graph.pdf( MEAN + STDDEV * i ) ] ).toBack();
									graph.zLabel[ -i ] = label( [ MEAN - STDDEV * i, 0 ], roundTo( 1, MEAN - STDDEV * i ), "below", { color: "#bbb" } );
									graph.zLabel[ i ] = label( [ MEAN + STDDEV * i, 0 ], roundTo( 1, MEAN + STDDEV * i ), "below", { color: "#bbb" } );
									i++;
								}
							});

							updateLine( 0, 0 );
							updateLine( 1, 1 );

							graph.shape = [];
							graph.shape.push([ MEAN, 0 ]);

							var step = STDDEV / 50;
							for ( var x = MEAN; x &lt;= MEAN + STDDEV; x += step ) {
								graph.shape.push([ x, graph.pdf( x ) ]);
							}

							graph.shape.push([ MEAN + STDDEV, graph.pdf( MEAN + STDDEV ) ]);
							graph.shape.push([ MEAN + STDDEV, 0 ]);
							graph.shape.push([ MEAN, 0 ]);

							style({ stroke: null, fill: BLUE, opacity: 0.3 }, function() {
								graph.blueShape = path( graph.shape );
							});

							style({ arrows: "-&gt;", stroke: GREEN }, function() {
								graph.leftArrow = path([
									[ MEAN + STDDEV * 0.5, -1.2 ],
									[ MEAN + STDDEV, -1.2 ]
								]);
								graph.rightArrow = path([
									[ MEAN + STDDEV * 0.5, -1.2 ],
									[ MEAN, -1.2 ]
								]);
							});

							graph.meanLabel = label( [ MEAN + STDDEV * 0.5, -1.4 ],
								roundTo( 2, ( EMPIRICAL[1] - EMPIRICAL[0] ) ) + "\\%", "above", { color: GREEN } );

							addMouseLayer();
							this.movablePoint = addMovablePoint({ coord: [MEAN, graph.pdf( MEAN )], constraints: { constrainY: true }, snapX: STDDEV, });
							this.movablePoint2 = addMovablePoint({ coord: [MEAN + STDDEV, graph.pdf( MEAN + STDDEV )], constraints: { constrainY: true }, snapX: STDDEV, });
							movablePoint.onMove = function( x, y ) {

								if ( x &gt;= movablePoint2.coord[0] || x &lt; MEAN - STDDEV * 3 || MEAN + STDDEV * 3 &lt; x ) {
									return false; // don't allow the point to move past the bounds
								}

							else {
								updateShape( roundTo( 0, ( x - MEAN ) / STDDEV ), roundTo( 0, ( movablePoint2.coord[0] - MEAN ) / STDDEV ), MEAN, STDDEV );
								updateArrow( roundTo( 0, ( x - MEAN ) / STDDEV ), roundTo( 0, ( movablePoint2.coord[0] - MEAN ) / STDDEV ), EMPIRICAL[( movablePoint2.coord[0] - MEAN )] - EMPIRICAL[( x - MEAN )], MEAN, STDDEV );
								updateLine( roundTo( 0, ( movablePoint.coord[0] - MEAN ) / STDDEV ), roundTo( 0, ( x - MEAN ) / STDDEV ) );
								return [x, graph.pdf( x )];
							}

						};
							movablePoint2.onMove = function( x, y ) {

							if ( x &lt;= movablePoint.coord[0] || x &lt; MEAN - STDDEV * 3 || MEAN + STDDEV * 3 &lt; x ) {
									return false; // don't allow the point to move past the bounds
								}
							else {
								updateShape( roundTo( 0, ( movablePoint.coord[0] - MEAN ) / STDDEV ), roundTo( 0, ( x - MEAN ) / STDDEV ), MEAN, STDDEV );
								updateArrow( roundTo( 0, ( movablePoint.coord[0] - MEAN ) / STDDEV ), roundTo( 0, ( x - MEAN ) / STDDEV ), EMPIRICAL[( x - MEAN )] - EMPIRICAL[( movablePoint.coord[0] - MEAN )], MEAN, STDDEV );
								updateLine( roundTo( 0, ( movablePoint2.coord[0] - MEAN ) / STDDEV ), roundTo( 0, ( x - MEAN ) / STDDEV ) );
								return [x, graph.pdf( x )];
							}

						};

					</div>
				</div>

				<div class="solution" data-forms="percent"><var>EMPIRICAL[Z2] - EMPIRICAL[Z1]</var></div>

				<div class="hints">
					<div>
						<div class="graphie" data-update="normaldist">	
							graph.zLine[ movablePoint.coord[0] ].attr({ stroke: "#bbb" });
							graph.zLabel[ movablePoint.coord[0] ].css({ color: "#bbb" });
							graph.zLine[ movablePoint2.coord[0] ].attr({ stroke: "#bbb" });
							graph.zLabel[ movablePoint2.coord[0] ].css({ color: "#bbb" });
							if( ( MEAN + STDDEV * Z1 ) &lt; movablePoint2.coord[0] ) {
								movablePoint.moveTo( MEAN + STDDEV * Z1, graph.pdf( MEAN + STDDEV * Z1 ) );
								movablePoint2.moveTo( MEAN + STDDEV * Z2, graph.pdf( MEAN + STDDEV * Z2 ) );
							}
							else {
								movablePoint2.moveTo( MEAN + STDDEV * Z2, graph.pdf( MEAN + STDDEV * Z2 ) );
								movablePoint.moveTo( MEAN + STDDEV * Z1, graph.pdf( MEAN + STDDEV * Z1 ) );
							}
						</div>
						<p>Move the orange dots to the points labeled <code><var>MEAN + STDDEV * Z1</var></code> and <code><var>MEAN + STDDEV * Z2</var></code> on the graph.</p>
					</div>

					<p>The green arrow indicates that the shaded area represents approximately <code><var>roundTo( 2, EMPIRICAL[Z2] - EMPIRICAL[Z1] )</var>\%</code> 
					of the total area under the curve (using percentages from the empirical rule). Therefore, the probability that <code>x</code> is between 
					<code><var>MEAN + STDDEV * Z1</var></code> and <code><var>MEAN + STDDEV * Z2</var></code> is <code>\approx \color{<var>GREEN</var>}{<var>roundTo( 2, EMPIRICAL[Z2] - EMPIRICAL[Z1] )</var>\%}</code>.</p>
				</div>
			</div>
		</div>
	</div>
</body>
</html>
